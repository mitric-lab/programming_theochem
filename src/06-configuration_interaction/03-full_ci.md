## Full Configuration Interaction

For the full configuration interaction, we want to implement a representation
of the full electronic Hamiltonian in second quantisation, which is given
in 
Chapter [6.2.1](./02-second_quantisation/01-introduction.md#operators-in-second-quantisation) 
as 

$$
  \hat{H} = \sum_{pq} h_{pq} a_p^\dagger a_q + \frac{1}{2} \sum_{pqrs} g_{pqrs} a_p^\dagger a_r^\dagger a_s a_q
  {{numeq}}{eq:hamiltonian_fci_impl}
$$
with the one-electron integrals $h_{pq}$ and two-electron integrals $g_{pqrs}$.

We shall utilise the Jordan-Wigner representation introduced in
Chapter [6.2.4](./02-second_quantisation/04-repr_ladder_operators.html#generalisation-to-m-sites):
$$
a_p^{(\dagger)} \rightarrow \sigma_z^{\otimes (p-1)} \otimes 
  a^{(\dagger)} \otimes \identity_2^{\otimes (M-p)}\,.
  {{numeq}}{eq:jw_ladder_operators_impl}
$$

### Sparse Matrices

In our case, every spin-orbital is one site, so for a molecule with $L$ 
(spatial) basis functions, we have $M = 2L$ sites, giving us a total dimension
of $2^{2L}$ for the Fock space. This exponential scaling produces ridiculously
large matrices, which are infeasible to store in memory. Take the 
water molecule with the cc-pVDZ basis set as an example, which has 24
spin-orbitals in total. This would give us a dimension 
of $2^{24} = 16,777,216$ for the Fock space. This might not seem too large
but remember that matrices have a quadratic scaling with the dimension, 
leading to $(2^{24})^2 \approx 2.8 \times 10^{14}$ elements for
**every** ladder operator in the expression for the Hamiltonian.
If the elements were stored with the standard double precision, this would
require $8 \times 2.8 \times 10^{14} \approx 2252$ TB of memory per Matrix.
This is infeasible to store in the memory of any computer available today.

Thankfully, if you have looked at the matrix representations of the 
ladder operators $a_p^{(\dagger)}$ for multiple sites, you might have noticed
that they contain many zeros. Such matrices are called sparse matrices,
and there are specialised libraries to store them and perform operations
on them efficiently. We will use the
[<i><b>C</b>ompressed <b>S</b>parse <b>C</b>olumn</i>](https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_column_(CSC_or_CCS))
representation as implemented in the SciPy library through the class
[`scipy.sparse.csc_matrix`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.sparse.csc_matrix.html).

### Implementation

We start by importing the necessary libraries:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:imports}}
```
Note that we have imported several functionalities from the `sparse` module,
which will help us to handle sparse matrices. Next, we define the matrices
$\identity_2$, $\sigma_z$, $a$ and $a^\dagger$ for a single site:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:one_site_operators}}
```

We also define a helper function to perform tensor products between two
sparse matrices in CSC format:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:csc_kron}}
```
This short function will become handy later.

Just like in the case of CIS, because we need lots of information from the
`HartreeFock` class, we will let our new `ConfigurationInteraction` class
inherit from it:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_declaration}}
```
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_initialise}}
```
When initialising the class, we define the vacuum state as a sparse vector
with a single 1 at the zeroth position using the
[`scipy.sparse.eye`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.sparse.eye.html)
function. We also called the method `self.get_fermionic_operators()`, which
generates the ladder operators for all sites. This method is defined as follows:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_get_fermionic_operators}}
```
This method iterates over every site and generates a list of $2\times 2$
matrices according to eq. {{eqref: eq:jw_ladder_operators_impl}}, but without
performing the tensor products. We then use the 
[`functools.reduce`](https://docs.python.org/3/library/functools.html#functools.reduce)
function to perform consecutive tensor products on the list of matrices with
the help of the `csc_kron` function. This gives us the $2^M \times 2^M$
matrix representation of all creation operators. Subsequently, the annihilation
operators are generated by taking the Hermitian conjugate of the creation
operators.

We can now construct the Hamiltonian according to 
eq. {{eqref: eq:hamiltonian_fci_impl}}:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_get_hamiltonian}}
```
Because the one- and two-electron integrals 
($h_{pq}$ and $g_{pqrs}$, respectively) are required to be in an orthogonal
basis, we must transform the corresponding tensors calculated in the 
`HartreeFock` class, which are in the (non-orthogonal) atomic orbital basis.
A reasonable basis is the molecular orbital basis, which we can obtain by
performing a Hartree-Fock calculation. The corresponding transformation
matrix is the matrix of MO coefficients. However, any orthogonal basis
would work here.

After performing the transformation with the help of `np.einsum`, we can
construct the Hamiltonian using eq. {{eqref: eq:hamiltonian_fci_impl}}.
Because the one- and two-electron integrals over orbitals with different
spins are zero, and our integrals are stored in the spatial orbital basis,
we should only include the contribution from an integral if both orbitals 
have the same spin. Since our basis has alternating spins, we can simply 
check if the two involved indices have the same parity by using the 
modulo operator `%`.

The only missing part now is the nuclear repulsion energy, which can be 
implemented as follows:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_get_nuclear_repulsion}}
```

Afterwards, we can define the method `run_ci`, which solves the eigenvalue
problem of the Hamiltonian:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_run_ci}}
```
Please ignore the part with `projector` for now; we will explain it later.
The eigenvalue problem is solved using the 
[`scipy.sparse.linalg.eigsh`](https://docs.scipy.org/doc/scipy-1.12.0/reference/generated/scipy.sparse.linalg.eigsh.html)
function, which is specifically designed for sparse matrices. The `k` parameter
specifies the number of eigenvalues to compute, and the `which` parameter
selects the property of the eigenvalues to return. In this case, we want the
lowest eigenvalues, so we set `which='SA'`.
The rest of the code just deals with the printing of the results. It should 
be noted that the binary representation of the indices with large 
contributions is used to represent the configurations, as we have discussed
in chapter 
[6.2.4](./02-second_quantisation/04-repr_ladder_operators.html##admonition-relation-to-binary-numbers).

We can now test our implementation by running a full CI calculation on the
H<sub>4</sub> molecule with the STO-3G basis set:
```python
{{#shiftinclude -4:../codes/06-configuration_interaction/configuration_interaction.py:h4_molecule}}
```
```python
{{#shiftinclude -4:../codes/06-configuration_interaction/configuration_interaction.py:ci_no_projector}}
```

The beginning of the console output should look like the following:
```txt
CI:
State   0: E =  -1.91510655 a.u.
  |01101001>:   0.12139232 (1.5 %)
  |10010110>:   0.12139232 (1.5 %)
  |11001100>:  -0.68984051 (47.6 %)
  |11110000>:   0.68984051 (47.6 %)

State   1: E =  -1.90077951 a.u.
  |10001110>:  -0.11993404 (1.4 %)
  |10110010>:   0.11993404 (1.4 %)
  |11011000>:  -0.26171566 (6.8 %)
  |11100100>:  -0.26171566 (6.8 %)
  |11101000>:  -0.90560203 (82.0 %)

State   2: E =  -1.90077951 a.u.
  |11010100>:  -0.73378629 (53.8 %)
  |11011000>:   0.44133796 (19.5 %)
  |11100100>:   0.44133796 (19.5 %)
  |11101000>:  -0.18906277 (3.6 %)

State   3: E =  -1.90077951 a.u.
  |11010100>:   0.64704164 (41.9 %)
  |11011000>:   0.46754512 (21.9 %)
  |11100100>:   0.46754512 (21.9 %)
  |11101000>:  -0.32845955 (10.8 %)

State   4: E =  -1.76431833 a.u.
  |00111100>:   0.19818047 (3.9 %)
  |11000011>:   0.17476900 (3.1 %)
  |11001100>:  -0.67786154 (45.9 %)
  |11110000>:  -0.67786154 (45.9 %)

State   5: E =  -1.70868550 a.u.
  |11011000>:   0.70647176 (49.9 %)
  |11100100>:  -0.70647176 (49.9 %)

State   6: E =  -1.61197081 a.u.
  |11000100>:   0.25001176 (6.3 %)
  |11001000>:  -0.55266271 (30.5 %)
  |11010000>:   0.28861985 (8.3 %)
  |11100000>:  -0.71774417 (51.5 %)

State   7: E =  -1.61197081 a.u.
  |11001000>:   0.45192397 (20.4 %)
  |11010000>:  -0.61588720 (37.9 %)
  |11100000>:  -0.61598418 (37.9 %)

State   8: E =  -1.61197081 a.u.
  |11000100>:   0.50175111 (25.2 %)
  |11001000>:   0.64610626 (41.7 %)
  |11010000>:   0.53438056 (28.6 %)
  |11100000>:  -0.10784100 (1.2 %)

State   9: E =  -1.61197081 a.u.
  |00110100>:   0.10191566 (1.0 %)
  |11000100>:  -0.80543718 (64.9 %)
  |11001000>:   0.19817885 (3.9 %)
  |11010000>:   0.46713859 (21.8 %)
  |11100000>:  -0.24530925 (6.0 %)
```

The ground state (state 0) mainly consists of the configurations
$\ket{11110000}$ and $\ket{11001100}$, which are the Hartree-Fock 
configuration and the doubly excited configuration from HOMO to LUMO,
respectively. The ground state thus has a multi-reference character, which
dictates the failure of the Hartree-Fock method to describe the system.

The states 1--3 are triplets, after which two singlets follow. The states
6--9 have the same energy, which suggests that they are quartets. But how
can we have a quartet with an even number of electrons? If we inspect the
configurations, we see that all the contributing configurations have 3
electrons. This is because our Hamiltonian is constructed in the basis
of **all** 8-site configurations, which includes among others the vacuum state 
as well as the state with 8 electrons. Therefore, we will also obtain 
all cationic and anionic states along with the electronically excited states 
(and the ground state, of course). Although this could be seen as a benefit, 
if only neutral states are desired, this would cost additional computational 
resources for a calculation that is already expensive.

To avoid this, we can project the Hamiltonian onto the subspace of neutral
states with the help of a projector. 

### Projector
A *projector* on a vector space $V$ is a linear operator $P:\ V \rightarrow V$
such that $P^2 = P$ (i.e. $P$ is *idempotent*). Given a state $\ket{\vec{k}}$,
we can construct a projector onto the subspace spanned by $\ket{\vec{k}}$ as
$$
  P = \ket{\vec{k}}\bra{\vec{k}}\,.
$$
We can show that $P$ is idempotent:
$$
  P^2 = \ket{\vec{k}}\bra{\vec{k}}\ket{\vec{k}}\bra{\vec{k}} = \ket{\vec{k}}\braket{\vec{k}|\vec{k}}\bra{\vec{k}} = \ket{\vec{k}}\bra{\vec{k}} = P\,.
$$
If we have a (pure or mixed) state $\ket{\psi}$, we can project it onto the
spanned by $\ket{\vec{k}}$ as
$$
  \ket{\psi'} = P\ket{\psi} = \ket{\vec{k}}\braket{\vec{k}|\psi}\,.
$$
If $\ket{\psi}$ has a component in the subspace spanned by $\ket{\vec{k}}$,
the inner product $\braket{\vec{k}|\psi}$ will be non-zero, and the projection
will yield $\ket{\vec{k}}$ weighted by this inner product. Otherwise, the
projection will yield zero.

We can also construct a projector onto the subspace spanned by multiple states
by summing over the projectors of the individual states:
$$
  P = \sum_k \ket{\vec{k}}\bra{\vec{k}}\,.
  {{numeq}}{eq:multiple_state_orhtogonal_projector}
$$
This works because our states are orthogonal to each other, from which the
idempotency of $P$ follows:
$$
  P^2 
  = \left(\sum_k \ket{\vec{k}}\bra{\vec{k}}\right)^2 
  = \sum_{k,k'} \ket{\vec{k}}\braket{\vec{k}|\vec{k'}}\bra{\vec{k'}} 
  = \sum_{k,k'} \delta_{kk'} \ket{\vec{k}}\bra{\vec{k'}}
  = \sum_k \ket{\vec{k}}\bra{\vec{k}}
  = P\,.
$$
Such projectors, i.e. projectors onto the subspace spanned by orthogonal
states, are called *orthogonal projectors*. It can be shown that orthogonal
projectors satisfy $P^\dagger = P$.

The projected Schr√∂dinger equation reads
$$
  \hat{H} P \ket{\psi} = E P \ket{\psi}\,,
$$
or equivalently, by multiplying from the left with $P$:
$$
  P \hat{H} P \ket{\psi} = E \ket{\psi}\,.
$$
Defining the projected Hamiltonian as $\hat{H}_P = P \hat{H} P$, we can
rewrite the equation as
$$
  \hat{H}_P \ket{\psi} = E \ket{\psi}\,.
$$

To fix the number of electrons in our CI calculation, we can project
the Hamiltonian onto the subspace with the selected number of electrons. This 
can be achieved by constructing all state vectors with the desired number of
electrons and calculating the projector according to 
eq. {{eqref: eq:multiple_state_orhtogonal_projector}}. 
An implementation of this is shown below:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_get_n_electron_subspace}}
```
At first, a list of all possible combinations of exactly `n` electrons is
generated using the function
[`itertools.combinations`](https://docs.python.org/3/library/itertools.html#itertools.combinations).
For each combination, we calculate the total `n`-electron creator by performing
consecutive matrix multiplications of the one-electron creators. The projector
is then constructed using eq. {{eqref: eq:multiple_state_orhtogonal_projector}}.

The `run_ci` already contains an option for the projector and will calculate
the projected Hamiltonian if a projector is provided. We can now test the
implementation by running a full CI calculation on the same H<sub>4</sub>
molecule with the STO-3G basis set, but this time with a projector:
```python
{{#shiftinclude -4:../codes/06-configuration_interaction/configuration_interaction.py:ci_projector}}
```

The beginning of the console output should now look like the following:
```txt
CI:
State   0: E =  -1.91510655 a.u.
  |01101001>:   0.12139232 (1.5 %)
  |10010110>:   0.12139232 (1.5 %)
  |11001100>:  -0.68984051 (47.6 %)
  |11110000>:   0.68984051 (47.6 %)

State   1: E =  -1.90077951 a.u.
  |11010100>:  -0.74308356 (55.2 %)
  |11011000>:   0.45141729 (20.4 %)
  |11100100>:   0.45141729 (20.4 %)

State   2: E =  -1.90077951 a.u.
  |11010100>:  -0.54058351 (29.2 %)
  |11011000>:  -0.47751742 (22.8 %)
  |11100100>:  -0.47751742 (22.8 %)
  |11101000>:   0.46418652 (21.5 %)

State   3: E =  -1.90077951 a.u.
  |10001110>:  -0.11425289 (1.3 %)
  |10110010>:   0.11425289 (1.3 %)
  |11010100>:  -0.34545872 (11.9 %)
  |11011000>:  -0.22376833 (5.0 %)
  |11100100>:  -0.22376833 (5.0 %)
  |11101000>:  -0.86270457 (74.4 %)

State   4: E =  -1.76431833 a.u.
  |00111100>:   0.19818047 (3.9 %)
  |11000011>:   0.17476900 (3.1 %)
  |11001100>:  -0.67786154 (45.9 %)
  |11110000>:  -0.67786154 (45.9 %)

State   5: E =  -1.70868550 a.u.
  |11011000>:  -0.70647176 (49.9 %)
  |11100100>:   0.70647176 (49.9 %)

State   6: E =  -1.50408379 a.u.
  |01011100>:   0.19156788 (3.7 %)
  |01110100>:  -0.55651221 (31.0 %)
  |01111000>:   0.10281058 (1.1 %)
  |10101100>:   0.51698940 (26.7 %)
  |10110100>:   0.10281058 (1.1 %)
  |11000101>:  -0.13652929 (1.9 %)
  |11001010>:  -0.36820394 (13.6 %)
  |11010001>:   0.39631757 (15.7 %)
```

We can see that the quartet states are now gone, and the new state 6 has
4 electrons.

### Complete Class
The complete `ConfigurationInteraction` class is shown below:
```python
{{#include ../codes/06-configuration_interaction/configuration_interaction.py:ci_class}}
```
